

## 数据库重构

### 2.1 代码重构

### 2.2 数据库重构

数据库重构是对数据库schema的一个简单变更，在保持其行为语义和信息语义的同时改进了它的设计———换言之，你既没有增加新功能，也没有破坏原有的功能，既没有增加新的数据，也没有改变原有数据的含义。

数据库schema既包括结构的方面，如表和视图的定义，也包括功能的方面，如存储过程和触发器。

数据库重构在概念上比代码重构更困难：代码重构只需要保持行为语义，而数据库重构还必须保持信息语义。

对于单应用数据库架构（微服务架构中，通常每个服务有自己专用的数据库）是最简单的情况——你的应用是唯一与数据库打交道的应用，这使你能够并行地对他们重构并同时进行部署。

对于多应用数据库架构，因为有多个外部程序同时与数据库交互，有一些程序再你的控制范围之外。在这种情况下，你不能假定所有的外部程序都会同时部署，因此必须支持一个转换期，在这一时期将同时支持老的schema和新的schema。

![](https://asdfex.oss-cn-qingdao.aliyuncs.com/picgo/20230110144114.png)

工作了数周，发现Customer表和Account表有一些奇怪的地方，如图2.3所示。将Balance列作为Customer表的一部分真的有意义吗？不，让我们通过“移动列”重构来改进我们的数据库设计。

![](https://asdfex.oss-cn-qingdao.aliyuncs.com/picgo/20230110144421.png)

#### 2.2.1 单应用数据库环境

让我们从一个例子开始，在这个例子中，我们在一个单应用数据库环境下将一个列从一个表移动到另一个表。这是你能遇到的最简单的情况，因为你可以完全控制数据库schema和访问数据库的应用源代码。这意味着你可以同时重构数据库schema和应用源代码-你不必同时支持原有的schema和新的schema，因为只有一个应用访问你的数据库。

在这种情况下，我们建议两个人一起结对编程；一个人应该具有应用编程技能，另一个人具有数据库开发技能，最好是两个人同时具有两种技能。这两个人先决定数据库schema是否需要重构。也许程序员对schema是否需要重构的看法是错误的，也许对如何最好地重构的看法是错误的。所以重构先在开发者沙盒中进行。当重构完成后，所做的变更被提升到项目集成环境中，然后对系统进行构建和测试，并根据需要进行缺陷修复。

为了在开发沙盒中进行“移动列”重构，这一对程序员先运行了所有的测试并看到测试通过。接着，他们编写了一个测试，因为他们采用的是测试驱动开发（TDD）的方式。测试可能是访问Account.Balance列中的一个值。在运行所有的测试并看到测试失败之后，他们引人了Account.Balance 列，如图2.4所示。他们再次运行测试并看到测试通过了。接下来他们对原有的测试进行重构，这些测试验证了顾客存款的功能可以与Account.Balance列很好地工作，而不是与Customer.Balance列。他们看到这些测试失败了，因此对存款功能进行重构，使它去访问Account.Balance。他们对测试套件和应用中的其他代码进行了类似的变更，诸如取款逻辑，这些代码以前是针对Customer.Balance的。

当应用再次运行起来之后，他们出于安全考虑，对Customer.Balance中的数据进行了备份，然后将数据从Customer.Balance拷贝到Account.Balance的对应行中。他们再次运行了所有的测试，确保数据迁移安全地完成了。为了完成schema变更，最后一步是删除Custom-er.Balance 列并再次运行所有的测试，如果需要的话对缺陷进行修复。当他们完成这些工作后，就将他们的变更提升到项目集成环境中去，前面我们曾提到这一点。

![](https://asdfex.oss-cn-qingdao.aliyuncs.com/picgo/20230110144636.png)

#### 2.2.2 多应用数据库环境

这种情况更困难，因为在接下来的一年半时间里，每个应用都会在不同的时间部署新的发布版本。为了实现数据库重构，你要完成与单应用数据库环境下同样的工作，但不是立即删除Customer.Balance 列。你会在至少一年半的“转换期”中同时保持这两个列，让开发团队有时间来更新并重新部署他们所有的应用。图2.5展示了转换期中的部分数据库schema。请注意有两个触发器，SynchronizeCustomerBalance 和 SynchronizeAccountBalance，在转换期中它们在生产环境里运行，确保两个列的数据同步。

为什么需要这么长的转换期？因为有些应用目前没有人开发，而另一些应用正采用传统的开发生命周期，差不多每年才会有一个新的发布版本--你的转换期必须同时考虑到速度慢的团队和速度快的团队。而且，因为你不能依靠一个应用同时更新两个列，所以需要一种像触发器这样的机制来保持它们的值同步。也有其他的方法能做到这一点，诸如使用视图或进行事后同步，但正如我们在第5章中所讨论的，我们发现触发器效果最好。

在转换期之后，你会删除原来的列和触发器，得到图2.4中的最终数据库schema。只有在足够的测试可以确保安全时，你才能删除它们。此时，你的重构就完成了。在第3章中，我们会详细讨论这个例子的实现过程。

![](https://asdfex.oss-cn-qingdao.aliyuncs.com/picgo/20230110145537.png)

#### 2.2.3 保持语义

在前面我们进行“移动列”重构将Balance列从Customer表移动到Account表时，你需要进行“引入列”转换作为其中的一个步骤。

从表面上来看，“引入列”像是一种相当好的重构；在表中加入了一个空列并没有改变表的语义，直到有新的功能开始使用这个列为止。但我们仍然认为这是一种转换（不是重构），因为它将不可避免地改变应用的行为。例如，如果你在表的中间引入该列，所有使用列位置来访问表（例如，代码引用第17列而不是其列名）的程序逻辑都会失败。而且，即使该列加在了表的末尾，与一个DB2表捆绑（bound）的COBOL程序也会失败，除非与新的schema再次捆绑。最后，实用性应该成为你的指导原则。如果我们把“引入列”称为一种重构，或称为"Yabba Dabba Do”，这会影响你应用它的方式吗？我们希望不会。


### 2.3 数据库重构的分类

我们将数据库重构分成了6类，如表2.1所示。引入这个分类策略是为了有利于本书的组织，同时也希望有利于将来的数据库重构工具的组织。我们的分类策略并不完美，例如，“用视图取代方法”重构可能同时属于架构分类和方法分类（我们将它放入架构分类）。

![](https://asdfex.oss-cn-qingdao.aliyuncs.com/picgo/20230111213731.png)

### 2.4 数据库味道

Fowler在他的著作（Fowler 1997）中引入了“代码味道”的概念，它是代码中的一类常见问题，表明需要进行重构。常见的代码味道包括switch语句、长方法、重复代码、特性羡慕等。类似地，有一些常见的数据库味道，表明可能需要进行重构（Ambler 2003）。这些味道包括：

* **多用途的列** 

如果一个列被用于多种用途，就有可能存在额外的代码来确保源数据以“正确的方式”使用

* **多用途的表** 

如果一个表被用于存放几种类型的实体，就可能存在设计缺陷。

* **重复的数据**

重复的数据对操作型（operational）数据库来说是一个严重的问题，因为如果数据存放在几个地方，不一致的机会就增加了。例如，常常会发现顾客信息被存放在组织机构中的许多不同地方。实际上，许多公司不能集中得到一份准确的清单，说明谁是他们的顾客。问题在于，一个表中的 John Smith 住在 Main 大街 123 号，而另一个表中的John Smith住在Elm大街456号。在这个例子中，实际上只有一个人，以前住在Main大街123号，去年搬到了Elm大街456号。不幸的是，John没有向贵公司提交两份地址变更表格，你的每个一知道他的应用都需要进行地址变更。

* **列太多的表**

当一个表包含太多的列时，就说明这个表缺乏内聚——它试图存放来自几类实体的数据。也许你的Customer表包含了一些列，存放了3个不同的地址（发货地址、账单地址、季节性地址）或几个电话号码（家庭电话、工作电话、移动电话，等等）。你可能需要将这种结构进行标准化处理，加入 Address 和 PhoneNumber 表。

* **行太多的表**

大的表就说明有性能问题。例如，在一个几百万行的表中查找是很花时间的。你可能需要对该表进行垂直分割，将一些列移到另一个表中，或者进行水平分割，将一些行移到另一个表中。这两种策略都会减小表的规模，可能改善性能。

* **“智能”列**

智能列是这样一种列，其中数据的不同位置代表不同的概念。例如，如果客户ID的前4位数字代表客户的开户行（home branch），那么客户ID就是一个智能列，因为你会解析它以取得更细粒度的信息（例如，开户行ID）。另一个例子是使用一个文本列来保存XML数据结构；很清楚，你需要解析XML数据结构获得粒度更小的数据字段。智能列常常需要重新组织成构成它的一些数据字段，这样数据库就能将它们作为单独的元素进行处理。

* **害怕变化**

如果你害怕改动你的数据库 schema，因为你担心会破坏什么东西——例如，50个访问该数据库的应用——那么这就是一个很明确的信号，你需要重构 schema。害怕变化本身就很好地说明了你在冒很严重的技术风险，这种情况会随时间的推移而变得更糟。

### 2.5 数据库重构在开发中的位置

### 2.6 使数据库schema的重构更容易