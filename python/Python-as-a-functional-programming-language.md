
作为函数式编程语言的 Python
=========================

## 什么是函数式编程

说实话，“函数式编程语言”是一个很大的话题。由于篇幅有限，本文不可能对这个话题做全面介绍。俺干脆偷一下懒，只简单说说。

从字面上看，所谓的函数式编程，就是以“函数”为中心的“编程范式”。估计有同学又会问了，啥是“编程范式”捏？哎呦，这又是一个很大的话题。通俗来讲，“编程范式”就是指编程的套路。比方说大家很熟悉的 OOP，就是一种“编程范式”。FP 跟 OOP 一样，都是一种编程的套路。做个简单类比：OOP 以“对象/类”作为程序设计的核心，而 FP 以“函数”作为程序设计的核心。


## Python 的函数语法

Python 中，常见的函数定义和函数调用，想必各位都晓得了。下面说几种不太常见的，且跟 FP 有关的语法。

### 函数赋值

Python 可以把函数直接赋值给一个变量。举例如下：

```py
def square(n) :  # 这是一个计算平方的小函数，后面会反复用它举例
    return n ** 2

f = square  # 此处赋值给变量 f
f(10)  # 此处返回100。注意：对该变量使用小括号，等同于调用函数
```

### 匿名定义

Python 可以用 lambda 关键字定义【单行】的匿名函数。套用刚才的例子

```py
square = lambda x : x**2  # 定义一个单参数的匿名函数，并把该函数赋值给变量
square(10)  # 此处返回 100
```

### 嵌套定义

Python 支持函数的嵌套定义（请看如下例子）。这种语法，在“闭包”中经常出现（后面会具体介绍“闭包”）

```py
def outer() :  # 外层函数
    s = "hello"
    def inner() :  # 内层函数
        print(s)  # 此处引用的是外层作用域的变量

    inner()  # 输出 hello
    s = "world"
    inner()  # 输出 world
```

## 和 FP 相关的内置函数

Python 内置了一大坨用于 FP 的函数，以方便程序猿写出简洁的代码。在接下去聊之前，俺有必要先介绍其中的2个。


### map(func, iter)

为了省事，俺只介绍2参数的 map（正宗的 map 支持 N 参数）。

参数 func 是个函数，参数 iter 是个迭代器（也可以理解为集合）

map() 会把 iter 的每个元素传给 func，并把每次调用的结果保存到一个 list 中，然后返回此 list。

举例：挨个计算整数 list 的平方：

```py
map(square, [1, 2, 3])  # 返回 [1, 4, 9]
```

### filter(func, iter)

参数含义同 map

filter() 会把 iter 的每个元素传给 func，如果 func 返回结果为 True，就把元素保存在一个 list 中，最后返回此 list。

举例：要过滤出所有奇数，代码如下：

```py
def odd(n) :
    return (n%2) == 1

filter(odd, [1, 2, 3])  # 返回[1, 3]
```

此处可以用上 lambda，把代码简化为一行：


```py
filter(lambda n: (n%2)==1, lst)
```

## 消除控制流

为了让大伙儿更深刻体会 FP 风格同传统风格的差别，俺把刚才两个例子组合一下——要求返回整数 list 中所有奇数的平方。

传统的写法（有控制流）：

```py
def func1(old_lst) :
    new_lst = []
    for n in old_lst :
        if odd(n) :
            new_lst.append(square(n))
    return new_lst
```

FP 的写法（无控制流）：

```py
def func2(lst) :
    return map(square, filter(odd, lst))
```

怎么样？是不是更简洁？连 for / if 这两个关键字都不需要了。


## List Comprehension

这个洋文比较难翻译。有人叫做“列表推导”，也有人称为“列表展开”或“列表解析”。（俺比较喜欢头一个翻译——不禁让人联想到“推倒”:）

在 Python 中，这是一个很好吃的语法糖——可以让你写出很简洁、很优雅的代码。

举例1：还拿刚才过滤奇数的例子。

```py
filter(lambda n: (n%2)==1, lst)
```

上述写法可以等价替换为列表推导：

```py
[n for n in lst if (n%2)==1]
```

举例2：再来一个稍微复杂的例子。假设有两个整数 list，分别存储矩形的宽度和高度。现在想把所有的宽度和高度进行两两组合，把大于 10 的面积打印出来。

传统的写法（2层循环，4行代码）

```py
for w in width :
    for h in height :
        if w*h > 10 :
            print(w*h)
```

FP 的写法（无循环，1行代码，多精致啊）

```py
print( [w*h for w in width for h in height if w*h > 10] )
```

除了列表推导，Python 中还有字典推导、集合推导等等。

## 闭包

闭包，洋文叫“closure”，解释在“这里”。它是 FP 的常见手法。那闭包到底有啥用捏？俺举一个微积分中，函数求导的例子。（不懂微积分或者对高数有心理阴影的同学，别担心，请把注意力集中在代码上）

```py
def d(f) :
    def calc(x) :
        dx = 0.000001  # 表示无穷小的Δx
        return (f(x+dx) - f(x)) / dx  # 计算斜率。注意，此处引用了外层作用域的变量 f
    return calc  # 此处用函数作为返回值（也就是函数 f 的导数）
```

现在，假设要计算二次函数 f(x) = x2 + x + 1 的导数，只需如下代码：

```py
f = lambda x : x**2 + x + 1  # 先把二次函数用代码表达出来
f1 = d(f)  # 这个f1 就是 f 的一阶导数啦。注意，导数依然是个函数
```

有了一阶导数，就可以很容易地计算该函数在某点的斜率

比如要计算 x=3 的斜率，只需：

```py
f1(3)
```

如果要想得到二阶导数（导数的导数），只需依样画葫芦（瞧这代码写得多优雅）

```py
f2 = d(f1)
```

看到这里，大伙儿不妨设想一下：如果不用 FP，改用 OOP，上述需求该如何实现？俺觉得吧，用 OOP 来求导，这代码写起来多半是又丑又臭。